#include "fk.h"
#include "ik.h"
#include <cmath>
#include <dynamixel_helper/dynamixel_helper.h>
#include <iostream>

void simulation() {
  // Thetas
  std::array<double, 5> initial_thetas{M_PI, M_PI, M_PI, M_PI, M_PI};
  std::array<double, 5> current_thetas = initial_thetas;

  std::array<double, 3> current_xyz = FK::where(current_thetas);

  // End effector poses [x, y, z, roll, pitch]
  std::array<double, 5> goal_pose{0.0, 0.0, 300.0, M_PI / 2.0, 0.0};
  std::array<double, 5> current_pose{
      current_xyz[0], current_xyz[1], current_xyz[2], current_thetas[4] - M_PI,
      current_thetas[1] + current_thetas[2] + current_thetas[3] - 3 * M_PI};

  // Other things
  double moving_status_threshold = 2 * 20 * 0.088 * M_PI / 180.0;

  // Wait until goal is reached
  bool still_moving;
  do {
    still_moving = false;
    // Go through current x, y, z, roll, pitch and compare to goal to see if we
    // are close yet.
    for (int i = 0; i < goal_pose.size(); i++)
      still_moving |=
          abs(goal_pose[i] - current_pose[i]) > moving_status_threshold;
    std::cout << current_pose[0] << '\t' << current_pose[1] << '\t'
              << current_pose[2] << '\t' << current_pose[3] << '\t'
              << current_pose[4] << '\t' << std::endl;

    // Update current thetas
    current_thetas = IK::get_next_thetas(current_thetas, goal_pose);
    // Update current xyz
    current_xyz = FK::where(current_thetas);
    // Update current pose
    current_pose = {current_xyz[0], current_xyz[1], current_xyz[2],
                    current_thetas[4] - M_PI,
                    current_thetas[1] + current_thetas[2] + current_thetas[3] -
                        3 * M_PI};

  } while (still_moving);
  std::cout << "Finished moving" << std::endl;
}

int main() {
  DynamixelHelper dh("/dev/ttyUSB0");
  dh.openPort();
  dh.setBaudrate(1000000);

  std::vector<uint8_t> motor_ids{1, 3, 4, 5, 6};

  // End effector goal pose [x, y, z, roll, pitch]
  std::array<double, 5> goal_pose{0.0, 0.0, 300.0, M_PI / 2.0, 0.0};

  // Result of latest group motor read
  std::vector<double> motor_read_result;

  // Place to store the next thetas generated by IK
  // before copying to dynamixel helper friendly data type
  std::array<double, 5> next_thetas;

  // Current pose information
  std::array<double, 5> current_thetas; // [theta1, theta2, ..., theta5]
  std::array<double, 3> current_xyz;    // [x, y, z]
  std::array<double, 5> current_pose;   // [x, y, z, roll, pitch]

  double goal_threshold = 10;

  // Enable torque before we try sending angles to the motors
  dh.groupTorqueEnable(motor_ids);

  bool approaching_goal = true;
  while (approaching_goal) {
    std::cout << "Working towards goal" << std::endl;
    // Get latest joint angles and overwrite old ones
    motor_read_result = dh.groupGetAngle(motor_ids);
    std::copy(motor_read_result.begin(), motor_read_result.end(),
              current_thetas.begin());

    // Construct current pose of robot
    current_xyz = FK::where(current_thetas);
    current_pose = {current_xyz[0], current_xyz[1], current_xyz[2],
                    current_thetas[4] - M_PI,
                    current_thetas[1] + current_thetas[2] + current_thetas[3] -
                        3 * M_PI};

    // Announce current pose
    std::cout << current_pose[0] << '\t' << current_pose[1] << '\t'
              << current_pose[2] << '\t' << current_pose[3] << '\t'
              << current_pose[4] << '\t' << std::endl;

    // Generate and send next step of movements
    next_thetas = IK::get_next_thetas(current_thetas, goal_pose);
    dh.groupSetAngle(
        motor_ids, std::vector<double>(next_thetas.begin(), next_thetas.end()));

    // // Wait for next thetas to be reached
    // bool moving;
    // do {
    //   std::cout << "Waiting for arm to reach new thetas" << std::endl;
    //   moving = false;
    //   // If any one motor is still moving we need to keep waiting
    //   for (auto id : motor_ids)
    //     moving |= dh.readMotor(id, 122);
    // } while (moving);

    // Stop if close enough to goal
    approaching_goal = false;
    for (int i = 0; i < goal_pose.size(); i++)
      approaching_goal |= abs(goal_pose[i] - current_pose[i]) > goal_threshold;
  }
  std::cout << "Goal reached" << std::endl;

  // Disable torque before exiting program so motor doesn't stay stiff until
  // power removed
  dh.groupTorqueDisable(motor_ids);

  return 0;
}
